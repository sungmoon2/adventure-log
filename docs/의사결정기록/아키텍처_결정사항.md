# 아키텍처 결정사항 v1.0

**작성일**: 2025-01-XX
**결정자**: sungmoon2
**상태**: 확정 및 구현됨

---

## ⚠️ 중요 공지

**이 문서는 왜 이렇게 설계했는지를 기록합니다.**

- 모든 결정에는 근거가 있음
- 대안을 검토했으나 선택하지 않은 이유 명시
- 나중에 다시 고민하지 않도록 명확히 기록

---

## 1. 결정 1: Jamstack 아키텍처 선택

### 1.1 결정 내용

```
백엔드 서버 없이 Jamstack 방식 채택
- 프론트엔드: React SPA (Vercel)
- 백엔드: Supabase (BaaS)
- 직접 통신: React → Supabase SDK → PostgreSQL
```

### 1.2 결정 배경

**원래 명세서**:
```
프론트엔드: React (Vercel)
백엔드: Flask (Railway)
데이터베이스: PostgreSQL (Railway)
```

**문제점**:
1. Flask 서버가 하는 일이 없음
   - CRUD만 수행 (비즈니스 로직 없음)
   - Supabase SDK로 충분히 대체 가능

2. 비용 문제
   - Railway 무료 플랜: 월 5달러 사용량, 500시간
   - 예상 초과 가능성 높음

3. 복잡도 증가
   - Flask 서버 관리 부담
   - 배포 파이프라인 2개 (Vercel + Railway)
   - CORS 설정 필요

4. Cold Start 문제
   - Railway 무료 플랜: 일정 시간 비활성 시 sleep
   - 첫 요청 시 5-10초 지연

### 1.3 대안 검토

#### 옵션 A: Jamstack (선택됨)
```
장점:
- 무료 (Vercel + Supabase = $0/월)
- 간단한 구조 (프론트엔드만 관리)
- Cold Start 없음
- 자동 스케일링

단점:
- 복잡한 비즈니스 로직 구현 어려움 (현재 해당 없음)
- Supabase 종속성
```

#### 옵션 B: Flask + Railway
```
장점:
- 백엔드 코드 완전 제어
- 복잡한 로직 구현 가능

단점:
- 비용 (월 5달러 초과 가능)
- 복잡도 증가
- Cold Start 문제
- 관리 포인트 증가
```

#### 옵션 C: Next.js (SSR/SSG)
```
장점:
- SEO 최적화 (현재 불필요)
- API Routes 사용 가능

단점:
- 현재 프로젝트에는 과도함
- 학습 곡선
- React만으로 충분함
```

### 1.4 최종 결정

**옵션 A (Jamstack) 선택**

**근거**:
1. 비용: 완전 무료
2. 요구사항: CRUD만 필요 (복잡한 로직 없음)
3. 성능: Cold Start 없음
4. 유지보수: 프론트엔드만 관리

---

## 2. 결정 2: Supabase vs Railway PostgreSQL

### 2.1 결정 내용

```
Supabase 선택 (PostgreSQL + Auth + Storage + Realtime 통합)
```

### 2.2 결정 배경

**비교표**:

| 항목 | Supabase | Railway PostgreSQL |
|------|----------|-------------------|
| 데이터베이스 | PostgreSQL 15 | PostgreSQL 15 |
| 무료 용량 | 500MB | 1GB |
| 인증 | ✅ 내장 (OAuth) | ❌ 직접 구현 |
| 파일 저장소 | ✅ 2GB Storage | ❌ 별도 서비스 필요 |
| Row Level Security | ✅ 지원 | ✅ 지원 |
| 실시간 | ✅ Realtime | ❌ 없음 |
| 백업 | ✅ 7일 자동 | ⚠️ 수동 |
| 비용 | $0 | $0 (DB만) + $5 (Flask) |

### 2.3 최종 결정

**Supabase 선택**

**근거**:
1. 인증 내장: Google OAuth 바로 사용
2. Storage 내장: 이미지 업로드 별도 서비스 불필요
3. 비용: 완전 무료 ($0)
4. 관리: 단일 플랫폼에서 모든 것 관리

---

## 3. 결정 3: React Router vs Next.js

### 3.1 결정 내용

```
React Router v7 사용 (CSR - Client Side Rendering)
```

### 3.2 결정 배경

**비교표**:

| 항목 | React Router (CSR) | Next.js (SSR/SSG) |
|------|-------------------|------------------|
| SEO | ❌ 제한적 | ✅ 우수 |
| 초기 로딩 | 느림 (JS 다운로드) | 빠름 (SSR) |
| 페이지 전환 | 빠름 (SPA) | 중간 |
| 복잡도 | 낮음 | 중간 |
| 배포 | 정적 파일 | Vercel 최적화 |
| 비용 | $0 | $0 |

### 2.3 최종 결정

**React Router (CSR) 선택**

**근거**:
1. SEO 불필요: 개인 프로젝트, 검색엔진 노출 불필요
2. 간단함: React만 학습하면 됨
3. 충분함: 모든 요구사항 충족
4. SPA 장점: 페이지 전환 빠름

---

## 4. 결정 4: TanStack Query vs Zustand vs Redux

### 4.1 결정 내용

```
서버 상태: TanStack Query v5
클라이언트 상태: React Context (Phase 1), Zustand (Phase 2 검토)
```

### 4.2 결정 배경

**상태 관리 비교**:

| 라이브러리 | 용도 | 장점 | 단점 |
|----------|------|------|------|
| TanStack Query | 서버 상태 | 캐싱, 리페칭 자동 | 서버 상태만 |
| Zustand | 클라이언트 상태 | 간단, 작은 번들 | 서버 상태 미지원 |
| Redux | 전역 상태 | 강력한 디버깅 | 보일러플레이트 많음 |
| React Context | 클라이언트 상태 | 내장, 추가 설치 불필요 | 성능 이슈 (큰 앱) |

### 4.3 최종 결정

**TanStack Query + React Context**

**근거**:
1. TanStack Query: 서버 상태 관리에 최적 (캐싱, 무효화, 리페칭)
2. React Context: 인증 상태만 관리 (충분함)
3. Phase 2 검토: 필터 상태 등 복잡해지면 Zustand 도입

---

## 5. 결정 5: Tailwind CSS vs styled-components vs CSS Modules

### 5.1 결정 내용

```
Tailwind CSS v4.1 사용
```

### 5.2 결정 배경

**비교표**:

| 방식 | 장점 | 단점 |
|------|------|------|
| Tailwind CSS | 빠른 개발, 일관성, 작은 번들 | 클래스명 길어짐 |
| styled-components | TypeScript 타입, 동적 스타일 | 번들 크기, 런타임 오버헤드 |
| CSS Modules | 간단, 전통적 | 재사용성 낮음 |

### 5.3 최종 결정

**Tailwind CSS 선택**

**근거**:
1. 개발 속도: 클래스명만으로 빠른 스타일링
2. 일관성: 디자인 시스템 자동 적용
3. 성능: 사용하지 않는 스타일 자동 제거 (PurgeCSS)
4. 반응형: 간단한 breakpoint

---

## 6. 결정 6: Vercel vs Netlify vs GitHub Pages

### 6.1 결정 내용

```
Vercel 사용 (프론트엔드 호스팅)
```

### 6.2 결정 배경

**비교표**:

| 플랫폼 | 대역폭 | 빌드 시간 | Edge Network | 비용 |
|--------|--------|-----------|--------------|------|
| Vercel | 100GB/월 | 100분/월 | ✅ 글로벌 | $0 |
| Netlify | 100GB/월 | 300분/월 | ✅ 글로벌 | $0 |
| GitHub Pages | 무제한 | N/A | ❌ 제한적 | $0 |

### 6.3 최종 결정

**Vercel 선택**

**근거**:
1. Vite 최적화: Vercel이 Vite를 만든 회사 (Vercel/vite)
2. 자동 배포: GitHub 연동 시 자동 배포
3. Preview URL: PR마다 자동 생성
4. 성능: Edge Network로 빠른 응답

---

## 7. 결정 7: Google OAuth vs Email/Password

### 7.1 결정 내용

```
Phase 1: Google OAuth만 지원
Phase 2: Email/Password 추가 검토
```

### 7.2 결정 배경

**비교표**:

| 방식 | 구현 난이도 | 보안 | 사용자 편의성 |
|------|-----------|------|--------------|
| Google OAuth | 낮음 (Supabase 내장) | 높음 | 높음 (1-click) |
| Email/Password | 중간 (비밀번호 재설정 등) | 중간 | 중간 |

### 7.3 최종 결정

**Google OAuth만 Phase 1에 구현**

**근거**:
1. 개인 프로젝트: 사용자 1명 (본인만)
2. 간단함: Supabase에서 바로 지원
3. 보안: Google이 관리
4. 추가 기능: Phase 2에서 필요 시 Email/Password 추가

---

## 8. 결정 8: Monorepo vs Separate Repos

### 8.1 결정 내용

```
Monorepo (단일 저장소)
adventure-log/
├── frontend/
├── database/
└── docs/
```

### 8.2 결정 배경

**비교표**:

| 방식 | 장점 | 단점 |
|------|------|------|
| Monorepo | 관리 편함, 버전 일치 | 저장소 크기 |
| Separate | 독립적 배포 | 동기화 어려움 |

### 8.3 최종 결정

**Monorepo 선택**

**근거**:
1. 작은 프로젝트: 복잡도 낮음
2. 버전 관리: 프론트엔드 + DB 스키마 + 문서 동기화
3. 배포: 프론트엔드만 배포 (Vercel이 자동으로 frontend/ 인식)

---

## 9. 결정 9: TypeScript Strict Mode

### 9.1 결정 내용

```json
{
  "compilerOptions": {
    "strict": true
  }
}
```

### 9.2 최종 결정

**Strict Mode 활성화**

**근거**:
1. 타입 안정성: 런타임 에러 방지
2. 코드 품질: any 사용 금지
3. 장기 유지보수: 버그 조기 발견

---

## 10. 결정 10: React 19 vs React 18

### 10.1 결정 내용

```
React 19.1.1 사용 (최신 버전)
```

### 10.2 최종 결정

**React 19 선택**

**근거**:
1. 최신 기능: Actions, useOptimistic 등
2. 안정성: React 19는 stable 릴리스
3. 성능 개선: 자동 배칭 개선
4. 호환성: 라이브러리들이 React 19 지원 시작

---

## 11. 변경 이력

| 날짜 | 결정 | 내용 | 작성자 |
|------|------|------|--------|
| 2025-01-XX | 1-10 | 초기 아키텍처 결정 | sungmoon2 |

---

**모든 결정은 근거가 있습니다.**
**나중에 "왜 이렇게 했지?"라는 질문에 답하기 위한 문서**
