# 데이터 모델 결정사항 v1.0

**작성일**: 2025-01-XX
**결정자**: sungmoon2
**상태**: 확정 및 배포됨

---

## ⚠️ 중요 공지

**이 문서는 왜 이 데이터 모델을 선택했는지 기록합니다.**

- 4가지 옵션을 검토함
- 각 옵션의 장단점 명시
- 최종 선택 근거 명확히 기록

---

## 1. 결정 배경

### 1.1 문제 상황

**원래 명세서**:
```sql
CREATE TABLE places (
    -- 모든 카테고리가 하나의 테이블에 섞임
    category VARCHAR(50),  -- '식당', '카페', '팝업/축제' 등
    operating_hours TEXT,  -- 모든 타입이 같은 필드 사용
    start_date DATE,       -- 팝업만 사용
    end_date DATE          -- 팝업만 사용
);
```

**문제점**:
1. **Single Table Inheritance (STI) 안티패턴**
   - 식당은 `start_date`, `end_date` 사용 안 함 (NULL)
   - 팝업은 `operating_hours` 사용 안 함 (NULL)
   - 많은 NULL 값 발생

2. **카테고리별 비즈니스 로직 상이**
   - 식당/카페: 영업시간 복잡 (요일별, 브레이크타임)
   - 팝업/축제: 기간 정보 (시작일, 종료일)
   - 명소: 항시 개방 또는 계절별

3. **확장성 문제**
   - 새 카테고리 추가 시 컬럼 추가 필요
   - 기존 데이터와 새 카테고리 간 불일치

---

## 2. 검토한 옵션

### 2.1 옵션 A: Single Table (STI)

**구조**:
```sql
CREATE TABLE places (
    id UUID PRIMARY KEY,
    category VARCHAR(50),
    -- 공통 필드
    name VARCHAR(255),
    address TEXT,
    -- 카테고리별 필드 (NULL 많음)
    operating_hours TEXT,     -- 식당/카페만
    start_date DATE,          -- 팝업만
    end_date DATE             -- 팝업만
);
```

**장점**:
- 간단한 쿼리
- 조인 불필요
- 전체 조회 빠름

**단점**:
- NULL 값 많음 (50% 이상 NULL 가능)
- 비즈니스 로직 복잡 (if category == '식당' then ...)
- 확장성 나쁨
- 데이터 무결성 약함 (식당에 start_date 입력 가능)

**점수**: 4/10

---

### 2.2 옵션 B: Class Table Inheritance (CTI)

**구조**:
```sql
-- 부모 테이블
CREATE TABLE places (
    id UUID PRIMARY KEY,
    name VARCHAR(255),
    address TEXT
);

-- 자식 테이블
CREATE TABLE restaurants (
    place_id UUID PRIMARY KEY REFERENCES places(id),
    operating_hours TEXT
);

CREATE TABLE popups (
    place_id UUID PRIMARY KEY REFERENCES places(id),
    start_date DATE,
    end_date DATE
);
```

**장점**:
- 데이터 무결성 강함
- NULL 값 없음
- 타입별 제약조건 명확

**단점**:
- 조인 필수 (성능 저하)
- 쿼리 복잡도 증가
- 전체 조회 시 UNION 필요
- 작은 프로젝트에는 과도함

**점수**: 6/10

---

### 2.3 옵션 C: Polymorphic Association (Hybrid)

**구조**:
```sql
CREATE TABLE places (
    id UUID PRIMARY KEY,
    category VARCHAR(50),
    -- 공통 필드
    name VARCHAR(255),
    address TEXT,
    -- 카테고리별 JSON
    category_data JSONB
);

-- category_data 예시
-- 식당: {"operating_hours": {"mon": "11-22", ...}}
-- 팝업: {"start_date": "2025-04-01", "end_date": "2025-04-10"}
```

**장점**:
- 유연함 (새 카테고리 추가 쉬움)
- NULL 값 없음
- 단일 테이블 (조인 불필요)

**단점**:
- JSONB 쿼리 복잡
- 인덱스 제한적
- 타입 안정성 낮음 (JSON은 자유형식)

**점수**: 7/10

---

### 2.4 옵션 D: Simplified Single Table (Phase 1 전용)

**구조**:
```sql
CREATE TABLE places (
    id UUID PRIMARY KEY,
    category VARCHAR(50),
    -- 공통 필드
    name VARCHAR(255),
    address TEXT,
    -- 단순화된 필드
    operating_hours TEXT,     -- 모든 카테고리 (자유 텍스트)
    start_date DATE,          -- 팝업/축제만 (NULL 허용)
    end_date DATE             -- 팝업/축제만 (NULL 허용)
);
```

**특징**:
- STI와 비슷하지만 **Phase 1 전용으로 한정**
- `operating_hours`를 TEXT로 단순화 (JSONB 아님)
- Phase 2에서 마이그레이션 계획 명시

**장점**:
- **빠른 구현** (MVP 목적에 적합)
- 간단한 쿼리
- 조인 불필요
- Phase 2 전환 계획 있음

**단점**:
- 여전히 NULL 값 존재
- 확장성 제한 (의도된 제약)

**점수**: 8/10 (MVP 기준)

---

## 3. 최종 결정

### 3.1 선택한 옵션

**옵션 D (Simplified Single Table) 선택**

### 3.2 선택 근거

**1. MVP 우선**
```
Phase 1 목표: 빠르게 만들어서 실제 사용
- 복잡한 정규화보다 빠른 구현이 중요
- 조인 없는 단순한 쿼리로 학습 곡선 낮춤
```

**2. 실제 사용 패턴 고려**
```
사용자 요구사항 (실제 대화 내용):
- "영업시간은 참고용이고 실제로는 네이버 지도 이용"
- operating_hours는 정확성 불필요 (간단한 메모 수준)
```

**3. 마이그레이션 계획 명시**
```
Phase 2 전환 계획:
1. operating_hours TEXT → JSONB
2. 카테고리별 테이블 분리 검토
3. 실사용 데이터 기반 최적화
```

**4. 비용 대비 효과**
```
개발 시간 절감:
- 옵션 B: 2-3일 (조인, CRUD 복잡도)
- 옵션 C: 1-2일 (JSONB 쿼리 학습)
- 옵션 D: 0.5일 (단순 CRUD)

MVP는 빠른 검증이 목적 → 옵션 D 최적
```

---

## 4. Phase 2 마이그레이션 계획

### 4.1 operating_hours 마이그레이션

**현재 (Phase 1)**:
```sql
operating_hours TEXT  -- "11:30-22:00, 월요일 휴무"
```

**Phase 2 변경**:
```sql
operating_hours JSONB  -- {"mon": {"open": "11:30", "close": "22:00"}, ...}
```

**마이그레이션 스크립트** (Phase 2에서 실행):
```sql
-- 1. 새 컬럼 추가
ALTER TABLE places ADD COLUMN operating_hours_new JSONB;

-- 2. 데이터 변환 (수동 또는 스크립트)
UPDATE places
SET operating_hours_new = '{}'::jsonb
WHERE category IN ('식당', '카페');

-- 3. 기존 컬럼 삭제, 새 컬럼 이름 변경
ALTER TABLE places DROP COLUMN operating_hours;
ALTER TABLE places RENAME COLUMN operating_hours_new TO operating_hours;
```

### 4.2 테이블 분리 검토

**Phase 2에서 데이터 100개+ 축적 후**:
1. NULL 값 비율 측정
2. 쿼리 성능 측정
3. 분리 필요 시 CTI로 전환

---

## 5. 필드별 결정사항

### 5.1 operating_hours (영업시간)

**Phase 1**: `TEXT`

**사용자 요구사항**:
```
"영업시간은 참고용이고 실제로는 네이버 지도를 이용함"
→ 정확한 파싱 불필요, 메모 수준으로 충분
```

**Phase 2**: `JSONB` (실시간 영업 중 표시 구현 시)

---

### 5.2 keywords (키워드)

**선택**: `TEXT[]` (PostgreSQL 배열)

**대안 검토**:

| 방식 | 장점 | 단점 |
|------|------|------|
| TEXT[] | 간단, GIN 인덱스 지원 | 정규화 안 됨 |
| tags 테이블 | 정규화, 자동완성 | 조인 필요 |

**결정**: Phase 1은 TEXT[], Phase 2에서 tags 테이블 추가

---

### 5.3 priority (우선순위)

**선택**: `VARCHAR(30)` (CHECK 제약조건)

**값**: `'🔥 최우선'`, `'✨ 꼭 가볼 곳'`, `'일반'`

**대안 검토**:

| 방식 | 장점 | 단점 |
|------|------|------|
| ENUM | 타입 안정성 | PostgreSQL ENUM 변경 어려움 |
| INT (1,2,3) | 간결 | 가독성 낮음 |
| VARCHAR + CHECK | 유연, 가독성 | 제약조건 관리 필요 |

**결정**: VARCHAR + CHECK (유연성과 가독성 균형)

---

### 5.4 record_status (레코드 상태)

**선택**: `'draft'` vs `'published'`

**목적**: Quick Save 지원

**사용 시나리오**:
```
Quick Save:
1. 인스타에서 장소 발견
2. 이름 + 카테고리 + URL만 입력 (draft)
3. 나중에 상세 정보 입력 후 published

일반 저장:
1. 모든 필드 입력
2. 바로 published
```

---

## 6. 인덱스 전략

### 6.1 선택한 인덱스 (12개)

```sql
-- 단일 인덱스 (8개)
CREATE INDEX idx_places_user ON places(user_id);
CREATE INDEX idx_places_category ON places(category);
CREATE INDEX idx_places_visit_status ON places(visit_status);
CREATE INDEX idx_places_priority ON places(priority);
CREATE INDEX idx_places_record_status ON places(record_status);
CREATE INDEX idx_places_region_main ON places(region_main);
CREATE INDEX idx_places_created_at ON places(created_at DESC);
CREATE INDEX idx_places_updated_at ON places(updated_at DESC);

-- GIN 인덱스 (1개)
CREATE INDEX idx_places_keywords ON places USING GIN(keywords);

-- 복합 인덱스 (3개)
CREATE INDEX idx_places_user_category ON places(user_id, category);
CREATE INDEX idx_places_user_visit_status ON places(user_id, visit_status);
CREATE INDEX idx_places_user_priority ON places(user_id, priority DESC, created_at DESC);
```

### 6.2 인덱스 선택 근거

**복합 인덱스 3개**:
```
자주 사용되는 쿼리:
1. 사용자별 + 카테고리별 조회
2. 사용자별 + 방문상태별 조회
3. 사용자별 + 우선순위 정렬 (대시보드)

→ 이 3가지 패턴에 최적화된 복합 인덱스
```

**GIN 인덱스**:
```
keywords TEXT[] 배열 검색 최적화
- 키워드 검색 빈도 높음
- GIN 인덱스로 배열 교집합 연산 빠름
```

---

## 7. 제약조건 전략

### 7.1 CHECK 제약조건

```sql
-- 카테고리 (5개만 허용)
CHECK (category IN ('식당', '카페', '문화/여가', '명소', '팝업/축제'))

-- 팝업 기간 검증
CHECK (
    (start_date IS NULL AND end_date IS NULL) OR
    (start_date IS NOT NULL AND end_date IS NOT NULL AND end_date >= start_date)
)
```

**장점**:
- 데이터베이스 레벨 검증 (애플리케이션 우회 불가)
- 불가능한 데이터 차단 (종료일 < 시작일)

---

## 8. Row Level Security (RLS)

### 8.1 RLS 정책 (4개)

```sql
-- SELECT
USING (auth.uid() = user_id)

-- INSERT
WITH CHECK (auth.uid() = user_id)

-- UPDATE
USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id)

-- DELETE
USING (auth.uid() = user_id)
```

### 8.2 RLS 선택 근거

**대안 비교**:

| 방식 | 장점 | 단점 |
|------|------|------|
| RLS | DB 레벨 보안, 우회 불가 | 복잡한 정책 관리 어려움 |
| API 레벨 | 유연한 로직 | 우회 가능, 버그 위험 |

**결정**: RLS (Jamstack이므로 API 없음, DB 레벨이 유일한 보안)

---

## 9. 변경 이력

| 날짜 | 결정 | 내용 | 작성자 |
|------|------|------|--------|
| 2025-01-XX | 옵션 D 선택 | Simplified Single Table (Phase 1) | sungmoon2 |

---

**데이터 모델은 완벽하지 않아도 됩니다.**
**Phase 1에서는 빠른 구현과 검증이 우선이며, Phase 2에서 최적화합니다.**
